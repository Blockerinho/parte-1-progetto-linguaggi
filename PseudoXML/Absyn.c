#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

SourceFile make_MainFile(ListTopLevelTag p1)
{
    SourceFile tmp = (SourceFile) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MainFile!\n");
        exit(1);
    }
    tmp->kind = is_MainFile;
    tmp->u.mainFile_.listtopleveltag_ = p1;
    return tmp;
}

ListTopLevelTag make_ListTopLevelTag(TopLevelTag p1, ListTopLevelTag p2)
{
    ListTopLevelTag tmp = (ListTopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListTopLevelTag!\n");
        exit(1);
    }
    tmp->topleveltag_ = p1;
    tmp->listtopleveltag_ = p2;
    return tmp;
}

TopLevelTag make_FileImportTag(String p1, int reached_section, int line)
{
    if (reached_section) {
      fprintf(stderr, "Error: imports must come before sections.\n");
      exit(1);
    }
    TopLevelTag tmp = (TopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FileImportTag!\n");
        exit(1);
    }
    tmp->kind = is_FileImportTag;
    tmp->line_number = line; 
    tmp->u.fileImportTag_.string_ = p1;
    return tmp;
}

TopLevelTag make_SectionTag(Ident p1, ListSubLevelTag p2, int line)
{
    TopLevelTag tmp = (TopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SectionTag!\n");
        exit(1);
    }
    tmp->kind = is_SectionTag;
    tmp->u.sectionTag_.ident_ = p1;
    tmp->u.sectionTag_.listsubleveltag_ = p2;
    tmp->line_number = line; 
    return tmp;
}

ListSubLevelTag make_ListSubLevelTag(SubLevelTag p1, ListSubLevelTag p2)
{
    ListSubLevelTag tmp = (ListSubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListSubLevelTag!\n");
        exit(1);
    }
    tmp->subleveltag_ = p1;
    tmp->listsubleveltag_ = p2;
    return tmp;
}

SubLevelTag make_FieldTag(Ident p1, Value p2, int line)
{
    SubLevelTag tmp = (SubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FieldTag!\n");
        exit(1);
    }
    tmp->kind = is_FieldTag;
    tmp->u.fieldTag_.ident_ = p1;
    tmp->u.fieldTag_.value_ = p2;
    tmp->line_number = line; 
    return tmp;
}

SubLevelTag make_InheritTag(Ident p1, int reached_field, int line)
{
    if (reached_field) {
      fprintf(stderr, "Error: inherited fields must come before normal ones.\n");
      exit(1);
    }
    SubLevelTag tmp = (SubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InheritTag!\n");
        exit(1);
    }
    tmp->kind = is_InheritTag;
    tmp->u.inheritTag_.ident_ = p1;
    tmp->line_number = line; 
    return tmp;
}

void free_SourceFile(SourceFile p)
{
  switch(p->kind)
  {
  case is_MainFile:
    free_ListTopLevelTag(p->u.mainFile_.listtopleveltag_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SourceFile!\n");
    exit(1);
  }
  free(p);
}

void free_ListTopLevelTag(ListTopLevelTag listtopleveltag)
{
  if (listtopleveltag)
  {
    free_TopLevelTag(listtopleveltag->topleveltag_);
    free_ListTopLevelTag(listtopleveltag->listtopleveltag_);
    free(listtopleveltag);
  }
}

void free_TopLevelTag(TopLevelTag p)
{
  switch(p->kind)
  {
  case is_FileImportTag:
    free(p->u.fileImportTag_.string_);
    break;

  case is_SectionTag:
    free(p->u.sectionTag_.ident_);
    free_ListSubLevelTag(p->u.sectionTag_.listsubleveltag_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TopLevelTag!\n");
    exit(1);
  }
  free(p);
}

void free_ListSubLevelTag(ListSubLevelTag listsubleveltag)
{
  if (listsubleveltag)
  {
    free_SubLevelTag(listsubleveltag->subleveltag_);
    free_ListSubLevelTag(listsubleveltag->listsubleveltag_);
    free(listsubleveltag);
  }
}

void free_SubLevelTag(SubLevelTag p)
{
  switch(p->kind)
  {
  case is_FieldTag:
    free(p->u.fieldTag_.ident_);
    free_Value(p->u.fieldTag_.value_);
    break;

  case is_InheritTag:
    free(p->u.inheritTag_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SubLevelTag!\n");
    exit(1);
  }
  free(p);
}

Value make_ValueInt(int val)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueInt!\n");
        exit(1);
    }
    tmp->kind = is_ValueInt;
    tmp->value_int = val;
    return tmp;
}

Value make_ValueBool(int val)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueBool!\n");
        exit(1);
    }
    tmp->kind = is_ValueBool;
    if (val) {
      tmp->value_bool = 1;
    } else {
      tmp->value_bool = 0;
    }
    return tmp;
}

Value make_ValueString(char* val)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueString!\n");
        exit(1);
    }
    tmp->kind = is_ValueString;
    tmp->value_string = val;
    return tmp;
}

Value make_ValueLocal(char* field_name)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_ValueLocal;
    tmp->value_local = field_name;
    return tmp;
}

Value make_ValueNonLocal(char* section_name, char* field_name)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_ValueNonLocal;
    tmp->value_nonlocal.section_name = section_name;
    tmp->value_nonlocal.field_name = field_name;
    return tmp;
}

void free_Value(Value p)
{
  switch(p->kind)
  {
  case is_ValueInt:
    break;

  case is_ValueBool:
    break;

  case is_ValueString:
    free(p->value_string);
    break;

  case is_ValueLocal:
    free(p->value_local);
    break;

  case is_ValueNonLocal:
    free(p->value_nonlocal.section_name);
    free(p->value_nonlocal.field_name);
    break;
  }
  free(p);
}

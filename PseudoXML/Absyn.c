/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   MainFile    ********************/

SourceFile make_MainFile(File p1)
{
    SourceFile tmp = (SourceFile) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MainFile!\n");
        exit(1);
    }
    tmp->kind = is_MainFile;
    tmp->u.mainFile_.file_ = p1;
    return tmp;
}

/********************   SimpleFile    ********************/

File make_SimpleFile(ListSectionDecl p1)
{
    File tmp = (File) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SimpleFile!\n");
        exit(1);
    }
    tmp->kind = is_SimpleFile;
    tmp->u.simpleFile_.listsectiondecl_ = p1;
    return tmp;
}

/********************   FileWImport    ********************/

File make_FileWImport(ListImport p1, ListSectionDecl p2)
{
    File tmp = (File) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FileWImport!\n");
        exit(1);
    }
    tmp->kind = is_FileWImport;
    tmp->u.fileWImport_.listimport_ = p1;
    tmp->u.fileWImport_.listsectiondecl_ = p2;
    return tmp;
}

/********************   ListSectionDecl    ********************/

ListSectionDecl make_ListSectionDecl(SectionDecl p1, ListSectionDecl p2)
{
    ListSectionDecl tmp = (ListSectionDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListSectionDecl!\n");
        exit(1);
    }
    tmp->sectiondecl_ = p1;
    tmp->listsectiondecl_ = p2;
    return tmp;
}

/********************   ListImport    ********************/

ListImport make_ListImport(Import p1, ListImport p2)
{
    ListImport tmp = (ListImport) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListImport!\n");
        exit(1);
    }
    tmp->import_ = p1;
    tmp->listimport_ = p2;
    return tmp;
}

/********************   FileImport    ********************/

Import make_FileImport(FilePath p1)
{
    Import tmp = (Import) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FileImport!\n");
        exit(1);
    }
    tmp->kind = is_FileImport;
    tmp->u.fileImport_.filepath_ = p1;
    return tmp;
}

/********************   Path    ********************/

FilePath make_Path(String p1)
{
    FilePath tmp = (FilePath) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Path!\n");
        exit(1);
    }
    tmp->kind = is_Path;
    tmp->u.path_.string_ = p1;
    return tmp;
}

/********************   SecDecl    ********************/

SectionDecl make_SecDecl(Ident p1, SectionContent p2)
{
    SectionDecl tmp = (SectionDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SecDecl!\n");
        exit(1);
    }
    tmp->kind = is_SecDecl;
    tmp->u.secDecl_.ident_ = p1;
    tmp->u.secDecl_.sectioncontent_ = p2;
    return tmp;
}

/********************   SimpleSecCont    ********************/

SectionContent make_SimpleSecCont(ListFieldDecl p1)
{
    SectionContent tmp = (SectionContent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SimpleSecCont!\n");
        exit(1);
    }
    tmp->kind = is_SimpleSecCont;
    tmp->u.simpleSecCont_.listfielddecl_ = p1;
    return tmp;
}

/********************   SecContent    ********************/

SectionContent make_SecContent(ListInherit p1, ListFieldDecl p2)
{
    SectionContent tmp = (SectionContent) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SecContent!\n");
        exit(1);
    }
    tmp->kind = is_SecContent;
    tmp->u.secContent_.listinherit_ = p1;
    tmp->u.secContent_.listfielddecl_ = p2;
    return tmp;
}

/********************   ListFieldDecl    ********************/

ListFieldDecl make_ListFieldDecl(FieldDecl p1, ListFieldDecl p2)
{
    ListFieldDecl tmp = (ListFieldDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListFieldDecl!\n");
        exit(1);
    }
    tmp->fielddecl_ = p1;
    tmp->listfielddecl_ = p2;
    return tmp;
}

/********************   ListInherit    ********************/

ListInherit make_ListInherit(Inherit p1, ListInherit p2)
{
    ListInherit tmp = (ListInherit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListInherit!\n");
        exit(1);
    }
    tmp->inherit_ = p1;
    tmp->listinherit_ = p2;
    return tmp;
}

/********************   InheritSection    ********************/

Inherit make_InheritSection(Ident p1)
{
    Inherit tmp = (Inherit) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InheritSection!\n");
        exit(1);
    }
    tmp->kind = is_InheritSection;
    tmp->u.inheritSection_.ident_ = p1;
    return tmp;
}

/********************   FieldDeclar    ********************/

FieldDecl make_FieldDeclar(Ident p1, Value p2)
{
    FieldDecl tmp = (FieldDecl) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FieldDeclar!\n");
        exit(1);
    }
    tmp->kind = is_FieldDeclar;
    tmp->u.fieldDeclar_.ident_ = p1;
    tmp->u.fieldDeclar_.value_ = p2;
    return tmp;
}

/********************   ValueInt    ********************/

Value make_ValueInt(Integer p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueInt!\n");
        exit(1);
    }
    tmp->kind = is_ValueInt;
    tmp->u.valueInt_.integer_ = p1;
    return tmp;
}

/********************   ValueBool    ********************/

Value make_ValueBool(Boolean p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueBool!\n");
        exit(1);
    }
    tmp->kind = is_ValueBool;
    tmp->u.valueBool_.boolean_ = p1;
    return tmp;
}

/********************   ValueString    ********************/

Value make_ValueString(String p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueString!\n");
        exit(1);
    }
    tmp->kind = is_ValueString;
    tmp->u.valueString_.string_ = p1;
    return tmp;
}

/********************   ValueNonLoc    ********************/

Value make_ValueNonLoc(NonLocVar p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_ValueNonLoc;
    tmp->u.valueNonLoc_.nonlocvar_ = p1;
    return tmp;
}

/********************   Boolean_true    ********************/

Boolean make_Boolean_true()
{
    Boolean tmp = (Boolean) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Boolean_true!\n");
        exit(1);
    }
    tmp->kind = is_Boolean_true;
    return tmp;
}

/********************   Boolean_false    ********************/

Boolean make_Boolean_false()
{
    Boolean tmp = (Boolean) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Boolean_false!\n");
        exit(1);
    }
    tmp->kind = is_Boolean_false;
    return tmp;
}

/********************   SimpleNonLoc    ********************/

NonLocVar make_SimpleNonLoc(Ident p1)
{
    NonLocVar tmp = (NonLocVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SimpleNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_SimpleNonLoc;
    tmp->u.simpleNonLoc_.ident_ = p1;
    return tmp;
}

/********************   NonLoc    ********************/

NonLocVar make_NonLoc(Ident p1, Ident p2)
{
    NonLocVar tmp = (NonLocVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NonLoc!\n");
        exit(1);
    }
    tmp->kind = is_NonLoc;
    tmp->u.nonLoc_.ident_1 = p1;
    tmp->u.nonLoc_.ident_2 = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

SourceFile clone_SourceFile(SourceFile p)
{
  switch(p->kind)
  {
  case is_MainFile:
    return make_MainFile (clone_File(p->u.mainFile_.file_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning SourceFile!\n");
    exit(1);
  }
}

File clone_File(File p)
{
  switch(p->kind)
  {
  case is_SimpleFile:
    return make_SimpleFile (clone_ListSectionDecl(p->u.simpleFile_.listsectiondecl_));

  case is_FileWImport:
    return make_FileWImport
      ( clone_ListImport(p->u.fileWImport_.listimport_)
      , clone_ListSectionDecl(p->u.fileWImport_.listsectiondecl_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning File!\n");
    exit(1);
  }
}

ListSectionDecl clone_ListSectionDecl(ListSectionDecl listsectiondecl)
{
  if (listsectiondecl)
  {
    /* clone of non-empty list */
    return make_ListSectionDecl
      ( clone_SectionDecl(listsectiondecl->sectiondecl_)
      , clone_ListSectionDecl(listsectiondecl->listsectiondecl_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListImport clone_ListImport(ListImport listimport)
{
  if (listimport)
  {
    /* clone of non-empty list */
    return make_ListImport
      ( clone_Import(listimport->import_)
      , clone_ListImport(listimport->listimport_)
      );
  }
  else return NULL; /* clone of empty list */
}

Import clone_Import(Import p)
{
  switch(p->kind)
  {
  case is_FileImport:
    return make_FileImport (clone_FilePath(p->u.fileImport_.filepath_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Import!\n");
    exit(1);
  }
}

FilePath clone_FilePath(FilePath p)
{
  switch(p->kind)
  {
  case is_Path:
    return make_Path (strdup(p->u.path_.string_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning FilePath!\n");
    exit(1);
  }
}

SectionDecl clone_SectionDecl(SectionDecl p)
{
  switch(p->kind)
  {
  case is_SecDecl:
    return make_SecDecl
      ( strdup(p->u.secDecl_.ident_)
      , clone_SectionContent(p->u.secDecl_.sectioncontent_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning SectionDecl!\n");
    exit(1);
  }
}

SectionContent clone_SectionContent(SectionContent p)
{
  switch(p->kind)
  {
  case is_SimpleSecCont:
    return make_SimpleSecCont (clone_ListFieldDecl(p->u.simpleSecCont_.listfielddecl_));

  case is_SecContent:
    return make_SecContent
      ( clone_ListInherit(p->u.secContent_.listinherit_)
      , clone_ListFieldDecl(p->u.secContent_.listfielddecl_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning SectionContent!\n");
    exit(1);
  }
}

ListFieldDecl clone_ListFieldDecl(ListFieldDecl listfielddecl)
{
  if (listfielddecl)
  {
    /* clone of non-empty list */
    return make_ListFieldDecl
      ( clone_FieldDecl(listfielddecl->fielddecl_)
      , clone_ListFieldDecl(listfielddecl->listfielddecl_)
      );
  }
  else return NULL; /* clone of empty list */
}

ListInherit clone_ListInherit(ListInherit listinherit)
{
  if (listinherit)
  {
    /* clone of non-empty list */
    return make_ListInherit
      ( clone_Inherit(listinherit->inherit_)
      , clone_ListInherit(listinherit->listinherit_)
      );
  }
  else return NULL; /* clone of empty list */
}

Inherit clone_Inherit(Inherit p)
{
  switch(p->kind)
  {
  case is_InheritSection:
    return make_InheritSection (strdup(p->u.inheritSection_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Inherit!\n");
    exit(1);
  }
}

FieldDecl clone_FieldDecl(FieldDecl p)
{
  switch(p->kind)
  {
  case is_FieldDeclar:
    return make_FieldDeclar
      ( strdup(p->u.fieldDeclar_.ident_)
      , clone_Value(p->u.fieldDeclar_.value_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning FieldDecl!\n");
    exit(1);
  }
}

Value clone_Value(Value p)
{
  switch(p->kind)
  {
  case is_ValueInt:
    return make_ValueInt (p->u.valueInt_.integer_);

  case is_ValueBool:
    return make_ValueBool (clone_Boolean(p->u.valueBool_.boolean_));

  case is_ValueString:
    return make_ValueString (strdup(p->u.valueString_.string_));

  case is_ValueNonLoc:
    return make_ValueNonLoc (clone_NonLocVar(p->u.valueNonLoc_.nonlocvar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Value!\n");
    exit(1);
  }
}

Boolean clone_Boolean(Boolean p)
{
  switch(p->kind)
  {
  case is_Boolean_true:
    return make_Boolean_true ();

  case is_Boolean_false:
    return make_Boolean_false ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Boolean!\n");
    exit(1);
  }
}

NonLocVar clone_NonLocVar(NonLocVar p)
{
  switch(p->kind)
  {
  case is_SimpleNonLoc:
    return make_SimpleNonLoc (strdup(p->u.simpleNonLoc_.ident_));

  case is_NonLoc:
    return make_NonLoc
      ( strdup(p->u.nonLoc_.ident_1)
      , strdup(p->u.nonLoc_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning NonLocVar!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_SourceFile(SourceFile p)
{
  switch(p->kind)
  {
  case is_MainFile:
    free_File(p->u.mainFile_.file_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SourceFile!\n");
    exit(1);
  }
  free(p);
}

void free_File(File p)
{
  switch(p->kind)
  {
  case is_SimpleFile:
    free_ListSectionDecl(p->u.simpleFile_.listsectiondecl_);
    break;

  case is_FileWImport:
    free_ListImport(p->u.fileWImport_.listimport_);
    free_ListSectionDecl(p->u.fileWImport_.listsectiondecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing File!\n");
    exit(1);
  }
  free(p);
}

void free_ListSectionDecl(ListSectionDecl listsectiondecl)
{
  if (listsectiondecl)
  {
    free_SectionDecl(listsectiondecl->sectiondecl_);
    free_ListSectionDecl(listsectiondecl->listsectiondecl_);
    free(listsectiondecl);
  }
}

void free_ListImport(ListImport listimport)
{
  if (listimport)
  {
    free_Import(listimport->import_);
    free_ListImport(listimport->listimport_);
    free(listimport);
  }
}

void free_Import(Import p)
{
  switch(p->kind)
  {
  case is_FileImport:
    free_FilePath(p->u.fileImport_.filepath_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Import!\n");
    exit(1);
  }
  free(p);
}

void free_FilePath(FilePath p)
{
  switch(p->kind)
  {
  case is_Path:
    free(p->u.path_.string_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FilePath!\n");
    exit(1);
  }
  free(p);
}

void free_SectionDecl(SectionDecl p)
{
  switch(p->kind)
  {
  case is_SecDecl:
    free(p->u.secDecl_.ident_);
    free_SectionContent(p->u.secDecl_.sectioncontent_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SectionDecl!\n");
    exit(1);
  }
  free(p);
}

void free_SectionContent(SectionContent p)
{
  switch(p->kind)
  {
  case is_SimpleSecCont:
    free_ListFieldDecl(p->u.simpleSecCont_.listfielddecl_);
    break;

  case is_SecContent:
    free_ListInherit(p->u.secContent_.listinherit_);
    free_ListFieldDecl(p->u.secContent_.listfielddecl_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SectionContent!\n");
    exit(1);
  }
  free(p);
}

void free_ListFieldDecl(ListFieldDecl listfielddecl)
{
  if (listfielddecl)
  {
    free_FieldDecl(listfielddecl->fielddecl_);
    free_ListFieldDecl(listfielddecl->listfielddecl_);
    free(listfielddecl);
  }
}

void free_ListInherit(ListInherit listinherit)
{
  if (listinherit)
  {
    free_Inherit(listinherit->inherit_);
    free_ListInherit(listinherit->listinherit_);
    free(listinherit);
  }
}

void free_Inherit(Inherit p)
{
  switch(p->kind)
  {
  case is_InheritSection:
    free(p->u.inheritSection_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Inherit!\n");
    exit(1);
  }
  free(p);
}

void free_FieldDecl(FieldDecl p)
{
  switch(p->kind)
  {
  case is_FieldDeclar:
    free(p->u.fieldDeclar_.ident_);
    free_Value(p->u.fieldDeclar_.value_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing FieldDecl!\n");
    exit(1);
  }
  free(p);
}

void free_Value(Value p)
{
  switch(p->kind)
  {
  case is_ValueInt:
    break;

  case is_ValueBool:
    free_Boolean(p->u.valueBool_.boolean_);
    break;

  case is_ValueString:
    free(p->u.valueString_.string_);
    break;

  case is_ValueNonLoc:
    free_NonLocVar(p->u.valueNonLoc_.nonlocvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Value!\n");
    exit(1);
  }
  free(p);
}

void free_Boolean(Boolean p)
{
  switch(p->kind)
  {
  case is_Boolean_true:
    break;

  case is_Boolean_false:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Boolean!\n");
    exit(1);
  }
  free(p);
}

void free_NonLocVar(NonLocVar p)
{
  switch(p->kind)
  {
  case is_SimpleNonLoc:
    free(p->u.simpleNonLoc_.ident_);
    break;

  case is_NonLoc:
    free(p->u.nonLoc_.ident_1);
    free(p->u.nonLoc_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing NonLocVar!\n");
    exit(1);
  }
  free(p);
}


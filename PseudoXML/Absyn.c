/* File generated by the BNF Converter (bnfc 2.9.6.1). */

/* C Abstract Syntax Implementation. */

#include <stdio.h>
#include <stdlib.h>
#include "Absyn.h"

/********************   MainFile    ********************/

SourceFile make_MainFile(ListTopLevelTag p1)
{
    SourceFile tmp = (SourceFile) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating MainFile!\n");
        exit(1);
    }
    tmp->kind = is_MainFile;
    tmp->u.mainFile_.listtopleveltag_ = p1;
    return tmp;
}

/********************   ListTopLevelTag    ********************/

ListTopLevelTag make_ListTopLevelTag(TopLevelTag p1, ListTopLevelTag p2)
{
    ListTopLevelTag tmp = (ListTopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListTopLevelTag!\n");
        exit(1);
    }
    tmp->topleveltag_ = p1;
    tmp->listtopleveltag_ = p2;
    return tmp;
}

/********************   FileImportTag    ********************/

TopLevelTag make_FileImportTag(String p1)
{
    TopLevelTag tmp = (TopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FileImportTag!\n");
        exit(1);
    }
    tmp->kind = is_FileImportTag;
    tmp->u.fileImportTag_.string_ = p1;
    return tmp;
}

/********************   SectionTag    ********************/

TopLevelTag make_SectionTag(Ident p1, ListSubLevelTag p2)
{
    TopLevelTag tmp = (TopLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SectionTag!\n");
        exit(1);
    }
    tmp->kind = is_SectionTag;
    tmp->u.sectionTag_.ident_ = p1;
    tmp->u.sectionTag_.listsubleveltag_ = p2;
    return tmp;
}

/********************   ListSubLevelTag    ********************/

ListSubLevelTag make_ListSubLevelTag(SubLevelTag p1, ListSubLevelTag p2)
{
    ListSubLevelTag tmp = (ListSubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ListSubLevelTag!\n");
        exit(1);
    }
    tmp->subleveltag_ = p1;
    tmp->listsubleveltag_ = p2;
    return tmp;
}

/********************   FieldTag    ********************/

SubLevelTag make_FieldTag(Ident p1, Value p2)
{
    SubLevelTag tmp = (SubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating FieldTag!\n");
        exit(1);
    }
    tmp->kind = is_FieldTag;
    tmp->u.fieldTag_.ident_ = p1;
    tmp->u.fieldTag_.value_ = p2;
    return tmp;
}

/********************   InheritTag    ********************/

SubLevelTag make_InheritTag(Ident p1)
{
    SubLevelTag tmp = (SubLevelTag) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating InheritTag!\n");
        exit(1);
    }
    tmp->kind = is_InheritTag;
    tmp->u.inheritTag_.ident_ = p1;
    return tmp;
}

/********************   ValueInt    ********************/

Value make_ValueInt(Integer p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueInt!\n");
        exit(1);
    }
    tmp->kind = is_ValueInt;
    tmp->u.valueInt_.integer_ = p1;
    return tmp;
}

/********************   ValueBool    ********************/

Value make_ValueBool(Boolean p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueBool!\n");
        exit(1);
    }
    tmp->kind = is_ValueBool;
    tmp->u.valueBool_.boolean_ = p1;
    return tmp;
}

/********************   ValueString    ********************/

Value make_ValueString(String p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueString!\n");
        exit(1);
    }
    tmp->kind = is_ValueString;
    tmp->u.valueString_.string_ = p1;
    return tmp;
}

/********************   ValueNonLoc    ********************/

Value make_ValueNonLoc(NonLocVar p1)
{
    Value tmp = (Value) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating ValueNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_ValueNonLoc;
    tmp->u.valueNonLoc_.nonlocvar_ = p1;
    return tmp;
}

/********************   Boolean_true    ********************/

Boolean make_Boolean_true()
{
    Boolean tmp = (Boolean) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Boolean_true!\n");
        exit(1);
    }
    tmp->kind = is_Boolean_true;
    return tmp;
}

/********************   Boolean_false    ********************/

Boolean make_Boolean_false()
{
    Boolean tmp = (Boolean) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating Boolean_false!\n");
        exit(1);
    }
    tmp->kind = is_Boolean_false;
    return tmp;
}

/********************   SimpleNonLoc    ********************/

NonLocVar make_SimpleNonLoc(Ident p1)
{
    NonLocVar tmp = (NonLocVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating SimpleNonLoc!\n");
        exit(1);
    }
    tmp->kind = is_SimpleNonLoc;
    tmp->u.simpleNonLoc_.ident_ = p1;
    return tmp;
}

/********************   NonLoc    ********************/

NonLocVar make_NonLoc(Ident p1, Ident p2)
{
    NonLocVar tmp = (NonLocVar) malloc(sizeof(*tmp));
    if (!tmp)
    {
        fprintf(stderr, "Error: out of memory when allocating NonLoc!\n");
        exit(1);
    }
    tmp->kind = is_NonLoc;
    tmp->u.nonLoc_.ident_1 = p1;
    tmp->u.nonLoc_.ident_2 = p2;
    return tmp;
}

/***************************   Cloning   ******************************/

SourceFile clone_SourceFile(SourceFile p)
{
  switch(p->kind)
  {
  case is_MainFile:
    return make_MainFile (clone_ListTopLevelTag(p->u.mainFile_.listtopleveltag_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning SourceFile!\n");
    exit(1);
  }
}

ListTopLevelTag clone_ListTopLevelTag(ListTopLevelTag listtopleveltag)
{
  if (listtopleveltag)
  {
    /* clone of non-empty list */
    return make_ListTopLevelTag
      ( clone_TopLevelTag(listtopleveltag->topleveltag_)
      , clone_ListTopLevelTag(listtopleveltag->listtopleveltag_)
      );
  }
  else return NULL; /* clone of empty list */
}

TopLevelTag clone_TopLevelTag(TopLevelTag p)
{
  switch(p->kind)
  {
  case is_FileImportTag:
    return make_FileImportTag (strdup(p->u.fileImportTag_.string_));

  case is_SectionTag:
    return make_SectionTag
      ( strdup(p->u.sectionTag_.ident_)
      , clone_ListSubLevelTag(p->u.sectionTag_.listsubleveltag_)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning TopLevelTag!\n");
    exit(1);
  }
}

ListSubLevelTag clone_ListSubLevelTag(ListSubLevelTag listsubleveltag)
{
  if (listsubleveltag)
  {
    /* clone of non-empty list */
    return make_ListSubLevelTag
      ( clone_SubLevelTag(listsubleveltag->subleveltag_)
      , clone_ListSubLevelTag(listsubleveltag->listsubleveltag_)
      );
  }
  else return NULL; /* clone of empty list */
}

SubLevelTag clone_SubLevelTag(SubLevelTag p)
{
  switch(p->kind)
  {
  case is_FieldTag:
    return make_FieldTag
      ( strdup(p->u.fieldTag_.ident_)
      , clone_Value(p->u.fieldTag_.value_)
      );

  case is_InheritTag:
    return make_InheritTag (strdup(p->u.inheritTag_.ident_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning SubLevelTag!\n");
    exit(1);
  }
}

Value clone_Value(Value p)
{
  switch(p->kind)
  {
  case is_ValueInt:
    return make_ValueInt (p->u.valueInt_.integer_);

  case is_ValueBool:
    return make_ValueBool (clone_Boolean(p->u.valueBool_.boolean_));

  case is_ValueString:
    return make_ValueString (strdup(p->u.valueString_.string_));

  case is_ValueNonLoc:
    return make_ValueNonLoc (clone_NonLocVar(p->u.valueNonLoc_.nonlocvar_));

  default:
    fprintf(stderr, "Error: bad kind field when cloning Value!\n");
    exit(1);
  }
}

Boolean clone_Boolean(Boolean p)
{
  switch(p->kind)
  {
  case is_Boolean_true:
    return make_Boolean_true ();

  case is_Boolean_false:
    return make_Boolean_false ();

  default:
    fprintf(stderr, "Error: bad kind field when cloning Boolean!\n");
    exit(1);
  }
}

NonLocVar clone_NonLocVar(NonLocVar p)
{
  switch(p->kind)
  {
  case is_SimpleNonLoc:
    return make_SimpleNonLoc (strdup(p->u.simpleNonLoc_.ident_));

  case is_NonLoc:
    return make_NonLoc
      ( strdup(p->u.nonLoc_.ident_1)
      , strdup(p->u.nonLoc_.ident_2)
      );

  default:
    fprintf(stderr, "Error: bad kind field when cloning NonLocVar!\n");
    exit(1);
  }
}

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_SourceFile(SourceFile p)
{
  switch(p->kind)
  {
  case is_MainFile:
    free_ListTopLevelTag(p->u.mainFile_.listtopleveltag_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SourceFile!\n");
    exit(1);
  }
  free(p);
}

void free_ListTopLevelTag(ListTopLevelTag listtopleveltag)
{
  if (listtopleveltag)
  {
    free_TopLevelTag(listtopleveltag->topleveltag_);
    free_ListTopLevelTag(listtopleveltag->listtopleveltag_);
    free(listtopleveltag);
  }
}

void free_TopLevelTag(TopLevelTag p)
{
  switch(p->kind)
  {
  case is_FileImportTag:
    free(p->u.fileImportTag_.string_);
    break;

  case is_SectionTag:
    free(p->u.sectionTag_.ident_);
    free_ListSubLevelTag(p->u.sectionTag_.listsubleveltag_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing TopLevelTag!\n");
    exit(1);
  }
  free(p);
}

void free_ListSubLevelTag(ListSubLevelTag listsubleveltag)
{
  if (listsubleveltag)
  {
    free_SubLevelTag(listsubleveltag->subleveltag_);
    free_ListSubLevelTag(listsubleveltag->listsubleveltag_);
    free(listsubleveltag);
  }
}

void free_SubLevelTag(SubLevelTag p)
{
  switch(p->kind)
  {
  case is_FieldTag:
    free(p->u.fieldTag_.ident_);
    free_Value(p->u.fieldTag_.value_);
    break;

  case is_InheritTag:
    free(p->u.inheritTag_.ident_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing SubLevelTag!\n");
    exit(1);
  }
  free(p);
}

void free_Value(Value p)
{
  switch(p->kind)
  {
  case is_ValueInt:
    break;

  case is_ValueBool:
    free_Boolean(p->u.valueBool_.boolean_);
    break;

  case is_ValueString:
    free(p->u.valueString_.string_);
    break;

  case is_ValueNonLoc:
    free_NonLocVar(p->u.valueNonLoc_.nonlocvar_);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Value!\n");
    exit(1);
  }
  free(p);
}

void free_Boolean(Boolean p)
{
  switch(p->kind)
  {
  case is_Boolean_true:
    break;

  case is_Boolean_false:
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing Boolean!\n");
    exit(1);
  }
  free(p);
}

void free_NonLocVar(NonLocVar p)
{
  switch(p->kind)
  {
  case is_SimpleNonLoc:
    free(p->u.simpleNonLoc_.ident_);
    break;

  case is_NonLoc:
    free(p->u.nonLoc_.ident_1);
    free(p->u.nonLoc_.ident_2);
    break;

  default:
    fprintf(stderr, "Error: bad kind field when freeing NonLocVar!\n");
    exit(1);
  }
  free(p);
}


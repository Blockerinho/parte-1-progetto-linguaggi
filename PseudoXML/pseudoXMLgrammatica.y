/* -*- c -*- File generated by the BNF Converter (bnfc 2.9.6.1). */

/* Parser definition to be used with Bison. */

/* Generate header file for lexer. */
%defines "Bison.h"

/* Reentrant parser */
%pure_parser
  /* From Bison 2.3b (2008): %define api.pure full */
%lex-param   { yyscan_t scanner }
%parse-param { yyscan_t scanner }

/* Turn on line/column tracking in the pseudo_xm_lgrammatica_lloc structure: */
%locations

/* Argument to the parser to be filled with the parsed tree. */
%parse-param { YYSTYPE *result }

%{
/* Begin C preamble code */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include "Absyn.h"

#define YYMAXDEPTH 10000000

/* The type yyscan_t is defined by flex, but we need it in the parser already. */
#ifndef YY_TYPEDEF_YY_SCANNER_T
#define YY_TYPEDEF_YY_SCANNER_T
typedef void* yyscan_t;
#endif

typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE pseudo_xm_lgrammatica__scan_string(const char *str, yyscan_t scanner);
extern void pseudo_xm_lgrammatica__delete_buffer(YY_BUFFER_STATE buf, yyscan_t scanner);

extern void pseudo_xm_lgrammatica_lex_destroy(yyscan_t scanner);
extern char* pseudo_xm_lgrammatica_get_text(yyscan_t scanner);

extern yyscan_t pseudo_xm_lgrammatica__initialize_lexer(FILE * inp);

/* List reversal functions. */
ListSectionDecl reverseListSectionDecl(ListSectionDecl l)
{
  ListSectionDecl prev = 0;
  ListSectionDecl tmp = 0;
  while (l)
  {
    tmp = l->listsectiondecl_;
    l->listsectiondecl_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListImport reverseListImport(ListImport l)
{
  ListImport prev = 0;
  ListImport tmp = 0;
  while (l)
  {
    tmp = l->listimport_;
    l->listimport_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListFieldDecl reverseListFieldDecl(ListFieldDecl l)
{
  ListFieldDecl prev = 0;
  ListFieldDecl tmp = 0;
  while (l)
  {
    tmp = l->listfielddecl_;
    l->listfielddecl_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}
ListInherit reverseListInherit(ListInherit l)
{
  ListInherit prev = 0;
  ListInherit tmp = 0;
  while (l)
  {
    tmp = l->listinherit_;
    l->listinherit_ = prev;
    prev = l;
    l = tmp;
  }
  return prev;
}

/* End C preamble code */
%}

%union
{
  int    _int;
  char   _char;
  double _double;
  char*  _string;
  SourceFile sourcefile_;
  File file_;
  ListSectionDecl listsectiondecl_;
  ListImport listimport_;
  Import import_;
  FilePath filepath_;
  SectionDecl sectiondecl_;
  SectionContent sectioncontent_;
  ListFieldDecl listfielddecl_;
  ListInherit listinherit_;
  Inherit inherit_;
  FieldDecl fielddecl_;
  Value value_;
  Boolean boolean_;
  NonLocVar nonlocvar_;
}

%{
void yyerror(YYLTYPE *loc, yyscan_t scanner, YYSTYPE *result, const char *msg)
{
  fprintf(stderr, "error: %d,%d: %s at %s\n",
    loc->first_line, loc->first_column, msg, pseudo_xm_lgrammatica_get_text(scanner));
}

int yyparse(yyscan_t scanner, YYSTYPE *result);

extern int yylex(YYSTYPE *lvalp, YYLTYPE *llocp, yyscan_t scanner);
%}

%token          _ERROR_
%token          _DOLLAR      /* $ */
%token          _DOT         /* . */
%token          _SLASH       /* / */
%token          _LT          /* < */
%token          _EQ          /* = */
%token          _GT          /* > */
%token          _KW_false    /* false */
%token          _KW_field    /* field */
%token          _KW_import   /* import */
%token          _KW_inherit  /* inherit */
%token          _KW_name     /* name */
%token          _KW_section  /* section */
%token          _KW_true     /* true */
%token<_string> T_Ident      /* Ident */
%token<_string> _STRING_
%token<_int>    _INTEGER_
%token<_string> _IDENT_

%type <sourcefile_> SourceFile
%type <file_> File
%type <listsectiondecl_> ListSectionDecl
%type <listimport_> ListImport
%type <import_> Import
%type <filepath_> FilePath
%type <sectiondecl_> SectionDecl
%type <sectioncontent_> SectionContent
%type <listfielddecl_> ListFieldDecl
%type <listinherit_> ListInherit
%type <inherit_> Inherit
%type <fielddecl_> FieldDecl
%type <value_> Value
%type <boolean_> Boolean
%type <nonlocvar_> NonLocVar

%start SourceFile

%%

SourceFile : File { $$ = make_MainFile($1); result->sourcefile_ = $$; }
;
File : ListSectionDecl { $$ = make_SimpleFile(reverseListSectionDecl($1)); }
  | ListImport ListSectionDecl { $$ = make_FileWImport(reverseListImport($1), reverseListSectionDecl($2)); }
;
ListSectionDecl : /* empty */ { $$ = 0; }
  | ListSectionDecl SectionDecl { $$ = make_ListSectionDecl($2, $1); }
;
ListImport : /* empty */ { $$ = 0; }
  | ListImport Import { $$ = make_ListImport($2, $1); }
;
Import : _LT _KW_import _GT FilePath _LT _SLASH _KW_import _GT { $$ = make_FileImport($4); }
;
FilePath : _STRING_ { $$ = make_Path($1); }
;
SectionDecl : _LT _KW_section _KW_name _EQ T_Ident _GT SectionContent _LT _SLASH _KW_section _GT { $$ = make_SecDecl($5, $7); }
;
SectionContent : ListFieldDecl { $$ = make_SimpleSecCont(reverseListFieldDecl($1)); }
  | ListInherit ListFieldDecl { $$ = make_SecContent(reverseListInherit($1), reverseListFieldDecl($2)); }
;
ListFieldDecl : /* empty */ { $$ = 0; }
  | ListFieldDecl FieldDecl { $$ = make_ListFieldDecl($2, $1); }
;
ListInherit : /* empty */ { $$ = 0; }
  | ListInherit Inherit { $$ = make_ListInherit($2, $1); }
;
Inherit : _LT _KW_inherit _GT T_Ident _LT _SLASH _KW_inherit _GT { $$ = make_InheritSection($4); }
;
FieldDecl : _LT _KW_field _KW_name _EQ T_Ident _GT Value _LT _SLASH _KW_field _GT { $$ = make_FieldDeclar($5, $7); }
;
Value : _INTEGER_ { $$ = make_ValueInt($1); }
  | Boolean { $$ = make_ValueBool($1); }
  | _STRING_ { $$ = make_ValueString($1); }
  | NonLocVar { $$ = make_ValueNonLoc($1); }
;
Boolean : _KW_true { $$ = make_Boolean_true(); }
  | _KW_false { $$ = make_Boolean_false(); }
;
NonLocVar : _DOLLAR T_Ident { $$ = make_SimpleNonLoc($2); }
  | _DOLLAR T_Ident _DOT T_Ident { $$ = make_NonLoc($2, $4); }
;

%%


/* Entrypoint: parse SourceFile from file. */
SourceFile pSourceFile(FILE *inp)
{
  YYSTYPE result;
  yyscan_t scanner = pseudo_xm_lgrammatica__initialize_lexer(inp);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  int error = yyparse(scanner, &result);
  pseudo_xm_lgrammatica_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.sourcefile_;
  }
}

/* Entrypoint: parse SourceFile from string. */
SourceFile psSourceFile(const char *str)
{
  YYSTYPE result;
  yyscan_t scanner = pseudo_xm_lgrammatica__initialize_lexer(0);
  if (!scanner) {
    fprintf(stderr, "Failed to initialize lexer.\n");
    return 0;
  }
  YY_BUFFER_STATE buf = pseudo_xm_lgrammatica__scan_string(str, scanner);
  int error = yyparse(scanner, &result);
  pseudo_xm_lgrammatica__delete_buffer(buf, scanner);
  pseudo_xm_lgrammatica_lex_destroy(scanner);
  if (error)
  { /* Failure */
    return 0;
  }
  else
  { /* Success */
    return result.sourcefile_;
  }
}




/* File generated by the BNF Converter (bnfc 2.9.6.1). */

#ifndef ABSYN_HEADER
#define ABSYN_HEADER

/* strdup was not in the ISO C standard before 6/2019 (C2x), but in POSIX 1003.1.
 * See: https://en.cppreference.com/w/c/experimental/dynamic/strdup
 * Setting _POSIX_C_SOURCE to 200809L activates strdup in string.h.
 */
#define _POSIX_C_SOURCE 200809L

#include <stddef.h>  /* NULL */
#include <string.h>  /* strdup */

/* C++ Abstract Syntax Interface.*/

/********************   TypeDef Section    ********************/

typedef int Integer;
typedef char Char;
typedef double Double;
typedef char* String;
typedef char* Ident;
typedef char* Ident;

/********************   Forward Declarations    ***********************/
struct SourceFile_;
typedef struct SourceFile_ *SourceFile;

struct File_;
typedef struct File_ *File;

struct ListSectionDecl_;
typedef struct ListSectionDecl_ *ListSectionDecl;

struct ListImport_;
typedef struct ListImport_ *ListImport;

struct Import_;
typedef struct Import_ *Import;

struct FilePath_;
typedef struct FilePath_ *FilePath;

struct SectionDecl_;
typedef struct SectionDecl_ *SectionDecl;

struct SectionContent_;
typedef struct SectionContent_ *SectionContent;

struct ListFieldDecl_;
typedef struct ListFieldDecl_ *ListFieldDecl;

struct ListInherit_;
typedef struct ListInherit_ *ListInherit;

struct Inherit_;
typedef struct Inherit_ *Inherit;

struct FieldDecl_;
typedef struct FieldDecl_ *FieldDecl;

struct Value_;
typedef struct Value_ *Value;

struct Boolean_;
typedef struct Boolean_ *Boolean;

struct NonLocVar_;
typedef struct NonLocVar_ *NonLocVar;

/********************   Abstract Syntax Classes    ********************/

struct SourceFile_
{
  enum { is_MainFile } kind;
  union
  {
    struct { File file_; } mainFile_;
  } u;
};

SourceFile make_MainFile(File p0);

struct File_
{
  enum { is_SimpleFile, is_FileWImport } kind;
  union
  {
    struct { ListSectionDecl listsectiondecl_; } simpleFile_;
    struct { ListImport listimport_; ListSectionDecl listsectiondecl_; } fileWImport_;
  } u;
};

File make_SimpleFile(ListSectionDecl p0);
File make_FileWImport(ListImport p0, ListSectionDecl p1);

struct ListSectionDecl_
{
  SectionDecl sectiondecl_;
  ListSectionDecl listsectiondecl_;
};

ListSectionDecl make_ListSectionDecl(SectionDecl p1, ListSectionDecl p2);

struct ListImport_
{
  Import import_;
  ListImport listimport_;
};

ListImport make_ListImport(Import p1, ListImport p2);

struct Import_
{
  enum { is_FileImport } kind;
  union
  {
    struct { FilePath filepath_; } fileImport_;
  } u;
};

Import make_FileImport(FilePath p0);

struct FilePath_
{
  enum { is_Path } kind;
  union
  {
    struct { String string_; } path_;
  } u;
};

FilePath make_Path(String p0);

struct SectionDecl_
{
  enum { is_SecDecl } kind;
  union
  {
    struct { Ident ident_; SectionContent sectioncontent_; } secDecl_;
  } u;
};

SectionDecl make_SecDecl(Ident p0, SectionContent p1);

struct SectionContent_
{
  enum { is_SimpleSecCont, is_SecContent } kind;
  union
  {
    struct { ListFieldDecl listfielddecl_; } simpleSecCont_;
    struct { ListFieldDecl listfielddecl_; ListInherit listinherit_; } secContent_;
  } u;
};

SectionContent make_SimpleSecCont(ListFieldDecl p0);
SectionContent make_SecContent(ListInherit p0, ListFieldDecl p1);

struct ListFieldDecl_
{
  FieldDecl fielddecl_;
  ListFieldDecl listfielddecl_;
};

ListFieldDecl make_ListFieldDecl(FieldDecl p1, ListFieldDecl p2);

struct ListInherit_
{
  Inherit inherit_;
  ListInherit listinherit_;
};

ListInherit make_ListInherit(Inherit p1, ListInherit p2);

struct Inherit_
{
  enum { is_InheritSection } kind;
  union
  {
    struct { Ident ident_; } inheritSection_;
  } u;
};

Inherit make_InheritSection(Ident p0);

struct FieldDecl_
{
  enum { is_FieldDeclar } kind;
  union
  {
    struct { Ident ident_; Value value_; } fieldDeclar_;
  } u;
};

FieldDecl make_FieldDeclar(Ident p0, Value p1);

struct Value_
{
  enum { is_ValueInt, is_ValueBool, is_ValueString, is_ValueNonLoc } kind;
  union
  {
    struct { Integer integer_; } valueInt_;
    struct { Boolean boolean_; } valueBool_;
    struct { String string_; } valueString_;
    struct { NonLocVar nonlocvar_; } valueNonLoc_;
  } u;
};

Value make_ValueInt(Integer p0);
Value make_ValueBool(Boolean p0);
Value make_ValueString(String p0);
Value make_ValueNonLoc(NonLocVar p0);

struct Boolean_
{
  enum { is_Boolean_true, is_Boolean_false } kind;
  union
  {
  } u;
};

Boolean make_Boolean_true(void);
Boolean make_Boolean_false(void);

struct NonLocVar_
{
  enum { is_SimpleNonLoc, is_NonLoc } kind;
  union
  {
    struct { Ident ident_; } simpleNonLoc_;
    struct { Ident ident_1, ident_2; } nonLoc_;
  } u;
};

NonLocVar make_SimpleNonLoc(Ident p0);
NonLocVar make_NonLoc(Ident p0, Ident p1);

/***************************   Cloning   ******************************/

SourceFile clone_SourceFile(SourceFile p);
File clone_File(File p);
ListSectionDecl clone_ListSectionDecl(ListSectionDecl p);
ListImport clone_ListImport(ListImport p);
Import clone_Import(Import p);
FilePath clone_FilePath(FilePath p);
SectionDecl clone_SectionDecl(SectionDecl p);
SectionContent clone_SectionContent(SectionContent p);
ListFieldDecl clone_ListFieldDecl(ListFieldDecl p);
ListInherit clone_ListInherit(ListInherit p);
Inherit clone_Inherit(Inherit p);
FieldDecl clone_FieldDecl(FieldDecl p);
Value clone_Value(Value p);
Boolean clone_Boolean(Boolean p);
NonLocVar clone_NonLocVar(NonLocVar p);

/********************   Recursive Destructors    **********************/

/* These free an entire abstract syntax tree
 * including all subtrees and strings.
 *
 * Will not work properly if there is sharing in the tree,
 * i.e., when some pointers are aliased.  In this case
 * it will attempt to free the same memory twice.
 */

void free_SourceFile(SourceFile p);
void free_File(File p);
void free_ListSectionDecl(ListSectionDecl p);
void free_ListImport(ListImport p);
void free_Import(Import p);
void free_FilePath(FilePath p);
void free_SectionDecl(SectionDecl p);
void free_SectionContent(SectionContent p);
void free_ListFieldDecl(ListFieldDecl p);
void free_ListInherit(ListInherit p);
void free_Inherit(Inherit p);
void free_FieldDecl(FieldDecl p);
void free_Value(Value p);
void free_Boolean(Boolean p);
void free_NonLocVar(NonLocVar p);


#endif
